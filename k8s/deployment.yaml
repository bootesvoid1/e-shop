# --- User Service Deployment ---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      volumes:
        - name: secrets-script-volume
          emptyDir: {}
      initContainers:
        - name: fetch-secrets
          image: google/cloud-sdk:alpine
          command: ['/bin/sh', '-c']
          env:
            - name: DB_PASSWORD_SECRET_NAME
              value: "ecommerce-db-password"
            - name: DB_CONNECTION_NAME_SECRET_NAME
              value: "ecommerce-db-connection-name"
            - name: JWT_SECRET_NAME
              value: "ecommerce-jwt-secret"
            - name: MAIL_ADDRESS_SECRET_NAME
              value: "ecommerce-mail-address"
            - name: MAIL_PASSWORD_SECRET_NAME
              value: "ecommerce-mail-password"
            - name: MAIL_HOST_SECRET_NAME
              value: "ecommerce-mail-host"
            - name: MAIL_PORT_SECRET_NAME
              value: "ecommerce-mail-port"
            # Add others if needed for user service
          args:
            - |
              set -eu
              SCRIPT_PATH="/mnt/secrets-fetched/secrets.env"
              echo "# Fetched secrets script for user-service" > $SCRIPT_PATH

              fetch_secret() {
                local secret_name=$1
                local env_var_name=$2
                echo "Fetching secret: $secret_name"
                secret_value=$(gcloud secrets versions access latest --secret=$secret_name)
                escaped_secret_value=$(printf '%s\n' "$secret_value" | sed "s/'/'\\\\''/g")
                echo "export $env_var_name='$escaped_secret_value'" >> $SCRIPT_PATH
              }

              fetch_secret "$DB_PASSWORD_SECRET_NAME" "DB_PASSWORD"
              fetch_secret "$DB_CONNECTION_NAME_SECRET_NAME" "DB_CONNECTION_NAME"
              fetch_secret "$JWT_SECRET_NAME" "JWT_SECRET"
              fetch_secret "$MAIL_ADDRESS_SECRET_NAME" "MAIL_ADDRESS"
              fetch_secret "$MAIL_PASSWORD_SECRET_NAME" "MAIL_PASSWORD"
              fetch_secret "$MAIL_HOST_SECRET_NAME" "MAIL_HOST"
              fetch_secret "$MAIL_PORT_SECRET_NAME" "MAIL_PORT"
              # Fetch others for user service...

              echo "User service secrets script created at $SCRIPT_PATH"
          volumeMounts:
            - name: secrets-script-volume
              mountPath: /mnt/secrets-fetched
      containers:
        - name: user
          image: gcr.io/e-shop-deploy/user-service:latest # Use the new specific image
          command: ["/bin/sh", "-c"]
          args:
            - |
              set -eu
              if [ -f /mnt/secrets-fetched/secrets.env ]; then
                echo "Sourcing secrets for user-service"
                . /mnt/secrets-fetched/secrets.env
              else
                echo "Error: User service secrets script not found!" >&2
                exit 1
              fi
              exec node dist/apps/user/main # Run the specific user main file
          ports:
            - containerPort: 3002 # Port the user service listens on internally
          volumeMounts:
            - name: secrets-script-volume
              mountPath: /mnt/secrets-fetched
          env:
            # Database config (adjust as needed, user might not need direct DB access if it's an API)
            - name: DB_HOST
              value: "35.240.49.17" # Your Cloud SQL Public IP
            - name: DB_PORT
              value: "3306"
            - name: DB_USERNAME
              value: "appuser"
            - name: DB_NAME
              value: "ecommercedb"
            # Secrets will be sourced from script
            - name: DB_PASSWORD
              value: ""
            - name: JWT_SECRET
              value: ""
            - name: MAIL_ADDRESS
              value: ""
            - name: MAIL_PASSWORD
              value: ""
            - name: MAIL_HOST
              value: ""
            - name: MAIL_PORT
              value: ""
          # Consider adding resource requests/limits and health checks here
---
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
    - protocol: TCP
      port: 3002 # Port exposed by the Service
      targetPort: 3002 # Port the container listens on
  type: LoadBalancer # Or ClusterIP if internal only
# --- End User Service ---

# --- Product Service Deployment ---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: product-service
  template:
    metadata:
      labels:
        app: product-service
    spec:
      volumes:
        - name: secrets-script-volume
          emptyDir: {}
      initContainers:
        - name: fetch-secrets
          image: google/cloud-sdk:alpine
          command: ['/bin/sh', '-c']
          env:
            - name: DB_PASSWORD_SECRET_NAME
              value: "ecommerce-db-password"
            - name: DB_CONNECTION_NAME_SECRET_NAME
              value: "ecommerce-db-connection-name"
            - name: JWT_SECRET_NAME
              value: "ecommerce-jwt-secret"
            # Add other relevant secrets for product service
          args:
            - |
              set -eu
              SCRIPT_PATH="/mnt/secrets-fetched/secrets.env"
              echo "# Fetched secrets script for product-service" > $SCRIPT_PATH

              fetch_secret() {
                local secret_name=$1
                local env_var_name=$2
                echo "Fetching secret: $secret_name"
                secret_value=$(gcloud secrets versions access latest --secret=$secret_name)
                escaped_secret_value=$(printf '%s\n' "$secret_value" | sed "s/'/'\\\\''/g")
                echo "export $env_var_name='$escaped_secret_value'" >> $SCRIPT_PATH
              }

              fetch_secret "$DB_PASSWORD_SECRET_NAME" "DB_PASSWORD"
              fetch_secret "$DB_CONNECTION_NAME_SECRET_NAME" "DB_CONNECTION_NAME"
              fetch_secret "$JWT_SECRET_NAME" "JWT_SECRET"
              # Fetch others for product service...

              echo "Product service secrets script created at $SCRIPT_PATH"
          volumeMounts:
            - name: secrets-script-volume
              mountPath: /mnt/secrets-fetched
      containers:
        - name: product
          image: gcr.io/e-shop-deploy/product-service:latest
          command: ["/bin/sh", "-c"]
          args:
            - |
              set -eu
              if [ -f /mnt/secrets-fetched/secrets.env ]; then
                echo "Sourcing secrets for product-service"
                . /mnt/secrets-fetched/secrets.env
              else
                echo "Error: Product service secrets script not found!" >&2
                exit 1
              fi
              exec node dist/apps/product/main
          ports:
            - containerPort: 3003
          volumeMounts:
            - name: secrets-script-volume
              mountPath: /mnt/secrets-fetched
          env:
            - name: DB_HOST
              value: "35.240.49.17"
            - name: DB_PORT
              value: "3306"
            - name: DB_USERNAME
              value: "appuser"
            - name: DB_NAME
              value: "ecommercedb"
            - name: DB_PASSWORD
              value: ""
            - name: JWT_SECRET
              value: ""
          # Add resource requests/limits and health checks
---
apiVersion: v1
kind: Service
metadata:
  name: product-service
spec:
  selector:
    app: product-service
  ports:
    - protocol: TCP
      port: 3003
      targetPort: 3003
  type: LoadBalancer
# --- End Product Service ---

# --- Transaction Service Deployment ---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: transaction-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: transaction-service
  template:
    metadata:
      labels:
        app: transaction-service
    spec:
      volumes:
        - name: secrets-script-volume
          emptyDir: {}
      initContainers:
        - name: fetch-secrets
          image: google/cloud-sdk:alpine
          command: ['/bin/sh', '-c']
          env:
            - name: DB_PASSWORD_SECRET_NAME
              value: "ecommerce-db-password"
            - name: DB_CONNECTION_NAME_SECRET_NAME
              value: "ecommerce-db-connection-name"
            - name: JWT_SECRET_NAME
              value: "ecommerce-jwt-secret"
            # Add other relevant secrets
          args:
            - |
              set -eu
              SCRIPT_PATH="/mnt/secrets-fetched/secrets.env"
              echo "# Fetched secrets script for transaction-service" > $SCRIPT_PATH

              fetch_secret() {
                local secret_name=$1
                local env_var_name=$2
                echo "Fetching secret: $secret_name"
                secret_value=$(gcloud secrets versions access latest --secret=$secret_name)
                escaped_secret_value=$(printf '%s\n' "$secret_value" | sed "s/'/'\\\\''/g")
                echo "export $env_var_name='$escaped_secret_value'" >> $SCRIPT_PATH
              }

              fetch_secret "$DB_PASSWORD_SECRET_NAME" "DB_PASSWORD"
              fetch_secret "$DB_CONNECTION_NAME_SECRET_NAME" "DB_CONNECTION_NAME"
              fetch_secret "$JWT_SECRET_NAME" "JWT_SECRET"
              # Fetch others...

              echo "Transaction service secrets script created at $SCRIPT_PATH"
          volumeMounts:
            - name: secrets-script-volume
              mountPath: /mnt/secrets-fetched
      containers:
        - name: transaction
          image: gcr.io/e-shop-deploy/transaction-service:latest
          command: ["/bin/sh", "-c"]
          args:
            - |
              set -eu
              if [ -f /mnt/secrets-fetched/secrets.env ]; then
                echo "Sourcing secrets for transaction-service"
                . /mnt/secrets-fetched/secrets.env
              else
                echo "Error: Transaction service secrets script not found!" >&2
                exit 1
              fi
              exec node dist/apps/transaction/main
          ports:
            - containerPort: 3005
          volumeMounts:
            - name: secrets-script-volume
              mountPath: /mnt/secrets-fetched
          env:
            - name: DB_HOST
              value: "35.240.49.17"
            - name: DB_PORT
              value: "3306"
            - name: DB_USERNAME
              value: "appuser"
            - name: DB_NAME
              value: "ecommercedb"
            - name: DB_PASSWORD
              value: ""
            - name: JWT_SECRET
              value: ""
          # Add resource requests/limits and health checks
---
apiVersion: v1
kind: Service
metadata:
  name: transaction-service
spec:
  selector:
    app: transaction-service
  ports:
    - protocol: TCP
      port: 3005
      targetPort: 3005
  type: LoadBalancer
# --- End Transaction Service ---

# --- E-Commerce Gateway Deployment ---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ecommerce-gateway
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ecommerce-gateway
  template:
    metadata:
      labels:
        app: ecommerce-gateway
    spec:
      volumes:
        - name: secrets-script-volume
          emptyDir: {}
      initContainers:
        - name: fetch-secrets
          image: google/cloud-sdk:alpine
          command: ['/bin/sh', '-c']
          env:
            # List secrets needed by the gateway (might be fewer)
            - name: DB_PASSWORD_SECRET_NAME
              value: "ecommerce-db-password"
            - name: DB_CONNECTION_NAME_SECRET_NAME
              value: "ecommerce-db-connection-name"
            - name: JWT_SECRET_NAME
              value: "ecommerce-jwt-secret"
            - name: MAIL_ADDRESS_SECRET_NAME
              value: "ecommerce-mail-address"
            - name: MAIL_PASSWORD_SECRET_NAME
              value: "ecommerce-mail-password"
            - name: MAIL_HOST_SECRET_NAME
              value: "ecommerce-mail-host"
            - name: MAIL_PORT_SECRET_NAME
              value: "ecommerce-mail-port"
            # Add others if needed for gateway
          args:
            - |
              set -eu
              SCRIPT_PATH="/mnt/secrets-fetched/secrets.env"
              echo "# Fetched secrets script for ecommerce-gateway" > $SCRIPT_PATH

              fetch_secret() {
                local secret_name=$1
                local env_var_name=$2
                echo "Fetching secret: $secret_name"
                secret_value=$(gcloud secrets versions access latest --secret=$secret_name)
                escaped_secret_value=$(printf '%s\n' "$secret_value" | sed "s/'/'\\\\''/g")
                echo "export $env_var_name='$escaped_secret_value'" >> $SCRIPT_PATH
              }

              fetch_secret "$DB_PASSWORD_SECRET_NAME" "DB_PASSWORD"
              fetch_secret "$DB_CONNECTION_NAME_SECRET_NAME" "DB_CONNECTION_NAME"
              fetch_secret "$JWT_SECRET_NAME" "JWT_SECRET"
              fetch_secret "$MAIL_ADDRESS_SECRET_NAME" "MAIL_ADDRESS"
              fetch_secret "$MAIL_PASSWORD_SECRET_NAME" "MAIL_PASSWORD"
              fetch_secret "$MAIL_HOST_SECRET_NAME" "MAIL_HOST"
              fetch_secret "$MAIL_PORT_SECRET_NAME" "MAIL_PORT"
              # Fetch others for gateway...

              echo "Gateway secrets script created at $SCRIPT_PATH"
          volumeMounts:
            - name: secrets-script-volume
              mountPath: /mnt/secrets-fetched
      containers:
        - name: gateway
          image: gcr.io/e-shop-deploy/ecommerce-gateway:latest
          command: ["/bin/sh", "-c"]
          args:
            - |
              set -eu
              if [ -f /mnt/secrets-fetched/secrets.env ]; then
                echo "Sourcing secrets for ecommerce-gateway"
                . /mnt/secrets-fetched/secrets.env
              else
                echo "Error: Gateway secrets script not found!" >&2
                exit 1
              fi
              # IMPORTANT: Update CORS origin in your e-commerce app's main.ts
              # to include your frontend's external IP when you know it.
              exec node dist/apps/e-commerce/main
          ports:
            - containerPort: 3000 # Gateway listens on 3000
          volumeMounts:
            - name: secrets-script-volume
              mountPath: /mnt/secrets-fetched
          env:
            - name: DB_HOST
              value: "35.240.49.17"
            - name: DB_PORT
              value: "3306"
            - name: DB_USERNAME
              value: "appuser"
            - name: DB_NAME
              value: "ecommercedb"
            - name: DB_PASSWORD
              value: ""
            - name: JWT_SECRET
              value: ""
            - name: MAIL_ADDRESS
              value: ""
            - name: MAIL_PASSWORD
              value: ""
            - name: MAIL_HOST
              value: ""
            - name: MAIL_PORT
              value: ""
            # Consider adding environment variables for service discovery
            # if the gateway needs to know internal service addresses.
            # Although in K8s, you'd typically use the Service DNS names.
            # e.g., USER_SERVICE_URL: http://user-service:3002
            # But if hardcoding internal ports, maybe not needed.
          # Add resource requests/limits and health checks
---
apiVersion: v1
kind: Service
metadata:
  name: ecommerce-gateway-service
spec:
  selector:
    app: ecommerce-gateway
  ports:
    - protocol: TCP
      port: 3000 # Expose gateway on 3000
      targetPort: 3000
  type: LoadBalancer # This will be your main API endpoint
# --- End E-Commerce Gateway Service ---

# --- Frontend Deployment (Assuming it's already correct) ---
# Make sure your frontend deployment and service are also present in this file.
# If not, add them back. The frontend service should also likely be LoadBalancer.
# Example (adjust image name/tags as needed):
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ecommerce-frontend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ecommerce-frontend
  template:
    metadata:
      labels:
        app: ecommerce-frontend
    spec:
      containers:
      - name: frontend
        image: gcr.io/e-shop-deploy/ecommerce-frontend:latest # Use your existing frontend image
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: ecommerce-frontend-service
spec:
  selector:
    app: ecommerce-frontend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: LoadBalancer # Frontend LoadBalancer
# --- End Frontend Deployment/Service ---

# --- Recommendation API Deployment (Assuming it's already correct) ---
# Make sure your recommendation API deployment and service are also present.
# Example (adjust image name/tags as needed):
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: recommendation-api
spec:
  replicas: 1
  selector:
    matchLabels:
      app: recommendation-api
  template:
    metadata:
      labels:
        app: recommendation-api
    spec:
      containers:
      - name: api
        image: gcr.io/e-shop-deploy/recommendation-api:latest # Use your existing API image
        ports:
        - containerPort: 8001
---
apiVersion: v1
kind: Service
metadata:
  name: recommendation-api-service
spec:
  selector:
    app: recommendation-api
  ports:
    - protocol: TCP
      port: 8001
      targetPort: 8001
  type: LoadBalancer # Recommendation API LoadBalancer
# --- End Recommendation API Deployment/Service ---