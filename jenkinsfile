pipeline {
    agent {
        kubernetes {
            yaml '''
apiVersion: v1
kind: Pod
spec:
  # Consider removing or verifying 'jenkins' SA has secret creation perms
  # serviceAccountName: jenkins
  containers:
  - name: jnlp
    image: jenkins/inbound-agent:latest
    resources:
      requests:
        memory: "128Mi"
        cpu: "50m"
      limits:
        memory: "512Mi"
        cpu: "250m"
    volumeMounts:
    - name: workspace-volume
      mountPath: /home/jenkins/agent
  - name: kaniko
    image: gcr.io/kaniko-project/executor:debug
    command:
    - sleep
    args:
    - infinity
    resources:
      requests:
        memory: "512Mi"
        cpu: "200m"
      limits:
        memory: "1Gi"
        cpu: "500m"
    volumeMounts:
    - name: workspace-volume
      mountPath: /workspace
    # Mount the dynamically created secret
    - name: kaniko-secret-volume
      mountPath: /kaniko/.docker
      readOnly: true
    workingDir: /workspace
  - name: gcloud
    image: google/cloud-sdk:latest
    command:
    - sleep
    args:
    - infinity
    resources:
      requests:
        memory: "128Mi"
        cpu: "50m"
      limits:
        memory: "512Mi"
        cpu: "250m"
    volumeMounts:
    - name: workspace-volume
      mountPath: /workspace
  volumes:
  - name: workspace-volume
    emptyDir: {}
  # Define the volume as a secret, to be created by the pipeline
  - name: kaniko-secret-volume
    secret:
      secretName: "kaniko-secret-${BUILD_NUMBER}" # Unique name per build
  restartPolicy: Never
'''
        }
    }
    environment {
        PROJECT_ID                 = 'e-shop-deploy'
        GCR_REGISTRY               = 'gcr.io'
        BACKEND_IMAGE              = 'ecommerce-backend'
        FRONTEND_IMAGE             = 'ecommerce-frontend'
        USER_SERVICE_IMAGE         = 'user-service'
        PRODUCT_SERVICE_IMAGE      = 'product-service'
        TRANSACTION_SERVICE_IMAGE  = 'transaction-service'
        RECOMMENDATION_API_IMAGE   = 'recommendation-api'
        DOCKER_TAG                 = "${env.BUILD_NUMBER}"
         GCP_CREDENTIALS_ID         = 'gcp-service-account-key' 
         JENKINS_NAMESPACE          = 'default'
    }
    stages {
        stage('Checkout Code') {
            steps {
                checkout scm
                script {
                    echo "âœ… Source code checked out successfully"
                    sh '''
                        echo "=== WORKSPACE CONTENTS ==="
                        ls -la
                        echo "=== CHECKING REQUIRED DIRECTORIES ==="
                        ls -la e-commerce-master/ || echo "âŒ e-commerce-master not found"
                        ls -la e-commerce-front-master/ || echo "âŒ e-commerce-front-master not found"
                        ls -la recommendation-service/ || echo "âŒ recommendation-service not found"
                        echo "=== CHECKING DOCKERFILES ==="
                        find . -name "Dockerfile*" -type f
                        find . -name "dockerfile*" -type f
                    '''
                }
            }
        }

        stage('Security Scan - Secrets') {
            steps {
                script {
                    echo "ðŸ” Running secret scanning (placeholder)"
                    // Implement actual secret scanning tool here (e.g., git-secrets, detect-secrets, TruffleHog)
                }
            }
        }
        stage('Setup Kaniko Secret') {
            steps {
                container('gcloud') {
                    withCredentials([file(credentialsId: 'gcp-service-account-key', variable: 'GCP_SA_KEY')]) {
                        script {
                            def secretName = "kaniko-secret-${BUILD_NUMBER}"
                            echo "ðŸ”§ Creating Kubernetes Secret '${secretName}' for Kaniko authentication..."
                            sh '''
                                echo "ðŸ”§ Setting up temporary GCloud auth to create secret..."
                                export GOOGLE_APPLICATION_CREDENTIALS="$GCP_SA_KEY"
                                gcloud auth activate-service-account --key-file="$GOOGLE_APPLICATION_CREDENTIALS"
                                # Ensure kubectl is configured (e.g., if using workload identity, this might be automatic)
                                # If not, you might need to get cluster credentials here too, but usually not needed for in-cluster ops if SA is correct.

                                echo "ðŸ”§ Generating Kaniko Docker config.json..."
                                mkdir -p /tmp/kaniko-auth

                                # Base-64 encode the JSON key for the standard Docker auth format using _json_key
                                AUTH=$(printf "_json_key:$(cat $GCP_SA_KEY)" | base64 -w0)

                                cat > /tmp/kaniko-auth/config.json <<EOF
                                            {
                                            "auths": {
                                                "gcr.io": {
                                                "auth": "$AUTH"
                                                },
                                                "us.gcr.io": {
                                                "auth": "$AUTH"
                                                },
                                                "eu.gcr.io": {
                                                "auth": "$AUTH"
                                                }
                                            }
                                            }
                                            EOF
                                echo "ðŸ“‹ Generated config.json content:"
                                cat /tmp/kaniko-auth/config.json

                                echo "ðŸ”§ Creating Kubernetes Secret '${secretName}' in namespace '${JENKINS_NAMESPACE}'..."
                                kubectl create secret generic ${secretName} \
                                    --from-file=config.json=/tmp/kaniko-auth/config.json \
                                    --namespace=${JENKINS_NAMESPACE} \
                                    --dry-run=client -o yaml | kubectl apply -f -

                                if [ $? -eq 0 ]; then
                                    echo "âœ… Kubernetes Secret '${secretName}' created successfully."
                                else
                                    echo "âŒ Failed to create Kubernetes Secret '${secretName}'."
                                    exit 1
                                fi
                            '''
                        }
                    }
                }
            }
        }

        stage('Setup Authentication') {
            parallel {
                stage('Setup GCloud Auth') {
                    steps {
                        container('gcloud') {
                            withCredentials([file(credentialsId: 'gcp-service-account-key', variable: 'GCP_SA_KEY')]) {
                                sh '''
                                    echo "ðŸ”§ Setting up GCloud authentication..."
                                    export GOOGLE_APPLICATION_CREDENTIALS="$GCP_SA_KEY"
                                    gcloud auth activate-service-account --key-file="$GOOGLE_APPLICATION_CREDENTIALS"
                                    # Configure Docker for gcloud commands if needed (e.g., docker pull/push outside Kaniko)
                                    # gcloud auth configure-docker gcr.io --quiet # Often not needed if Kaniko handles push
                                    echo "âœ… GCloud authentication configured"
                                '''
                            }
                        }
                    }
                }               
                
            } 
        }     
             
                

                    
                
           
        stage('Build Images') {
            steps {
                container('kaniko') {
                    script {
                        echo "ðŸ”¨ Building Docker images with Kaniko..."
                        // Define build configurations - VERIFY THESE PATHS EXIST IN YOUR REPO
                        def buildConfigs = [
                            [
                                name: "BACKEND",
                                contextDir: "e-commerce-master",
                                dockerfile: "e-commerce-master/Dockerfile.backend", // Verify path
                                image: env.BACKEND_IMAGE
                            ],
                            [
                                name: "FRONTEND",
                                contextDir: "e-commerce-front-master",
                                dockerfile: "e-commerce-front-master/dockerfile.frontend", // Verify path & case
                                image: env.FRONTEND_IMAGE
                            ],
                            [
                                name: "RECOMMENDATION API",
                                contextDir: "recommendation-service",
                                dockerfile: "recommendation-service/Dockerfile", // Verify path
                                image: env.RECOMMENDATION_API_IMAGE
                            ],
                            [
                                name: "USER SERVICE",
                                contextDir: "e-commerce-master",
                                dockerfile: "e-commerce-master/Dockerfile.user", // Verify path
                                image: env.USER_SERVICE_IMAGE
                            ],
                            [
                                name: "PRODUCT SERVICE",
                                contextDir: "e-commerce-master",
                                dockerfile: "e-commerce-master/Dockerfile.product", // Verify path
                                image: env.PRODUCT_SERVICE_IMAGE
                            ],
                            [
                                name: "TRANSACTION SERVICE",
                                contextDir: "e-commerce-master",
                                dockerfile: "e-commerce-master/Dockerfile.transaction", // Verify path
                                image: env.TRANSACTION_SERVICE_IMAGE
                            ]
                        ]

                        // Check if required directories/files exist before building
                        boolean allPreconditionsMet = true
                        buildConfigs.each { config ->
                            sh """
                                echo "=== CHECKING PRECONDITIONS FOR ${config.name} ==="
                                CONTEXT_EXISTS=\$([ -d "${config.contextDir}" ] && echo "YES" || echo "NO")
                                DOCKERFILE_EXISTS=\$([ -f "${config.dockerfile}" ] && echo "YES" || echo "NO")
                                echo "   Context: ${config.contextDir} (exists: \$CONTEXT_EXISTS)"
                                echo "   Dockerfile: ${config.dockerfile} (exists: \$DOCKERFILE_EXISTS)"
                                if [ "\$CONTEXT_EXISTS" != "YES" ] || [ "\$DOCKERFILE_EXISTS" != "YES" ]; then
                                    echo "âŒ ${config.name}: Missing required files/directories."
                                    exit 1 # Fail the script step if preconditions fail
                                fi
                            """
                        }


                        // Build each image
                        buildConfigs.each { config ->
                            sh """
                                echo "=== BUILDING ${config.name} IMAGE ==="

                                # Build with Kaniko (using config.json from mounted secret volume)
                                /kaniko/executor \\
                                  --context="\$(pwd)/${config.contextDir}" \\
                                  --dockerfile="\$(pwd)/${config.dockerfile}" \\
                                  --destination=${GCR_REGISTRY}/${PROJECT_ID}/${config.image}:${DOCKER_TAG} \\
                                  --destination=${GCR_REGISTRY}/${PROJECT_ID}/${config.image}:latest \\
                                  --cache=true \\ # Ensure cache is configured or remove if not needed
                                  --cleanup \\
                                  --verbosity=info

                                if [ \$? -eq 0 ]; then
                                    echo "âœ… ${config.name} image built and pushed successfully"
                                else
                                    echo "âŒ Failed to build/push ${config.name} image"
                                    exit 1
                                fi
                                echo ""
                            """
                        }
                        echo "ðŸŽ‰ All images built successfully!"
                    }
                }
            }
        }

        stage('Verify Images') {
            steps {
                container('gcloud') {
                    withCredentials([file(credentialsId: 'gcp-service-account-key', variable: 'GCP_SA_KEY')]) {
                        sh '''
                            echo "ðŸ” Verifying pushed images..."
                            export GOOGLE_APPLICATION_CREDENTIALS="$GCP_SA_KEY"
                            # Re-authenticate gcloud for this step
                            gcloud auth activate-service-account --key-file="$GOOGLE_APPLICATION_CREDENTIALS"

                            # List images in registry
                            echo "Images in registry:"
                            gcloud container images list --repository=${GCR_REGISTRY}/${PROJECT_ID} || echo "âš ï¸  Failed to list images"

                            # Check specific image tags
                            echo "Image tags for build $BUILD_NUMBER:"
                            for image in $BACKEND_IMAGE $FRONTEND_IMAGE $USER_SERVICE_IMAGE $PRODUCT_SERVICE_IMAGE $TRANSACTION_SERVICE_IMAGE $RECOMMENDATION_API_IMAGE; do
                                echo "Checking $image:$BUILD_NUMBER..."
                                gcloud container images list-tags ${GCR_REGISTRY}/${PROJECT_ID}/$image --filter="tags:$BUILD_NUMBER" --format="table(digest,tags,timestamp)" || echo "âš ï¸  Image $image:$BUILD_NUMBER not found/listing failed"
                            done
                        '''
                    }
                }
            }
        }

        stage('Deploy to GKE') {
            steps {
                container('gcloud') {
                    withCredentials([file(credentialsId: 'gcp-service-account-key', variable: 'GCP_SA_KEY')]) {
                        sh '''
                            echo "ðŸ”§ Setting up GCloud authentication for deployment..."
                            export GOOGLE_APPLICATION_CREDENTIALS="$GCP_SA_KEY"
                            # Activate service account (redundant if pod SA has perms, but good practice)
                            gcloud auth activate-service-account --key-file="$GOOGLE_APPLICATION_CREDENTIALS"

                            # Get GKE cluster credentials
                            gcloud container clusters get-credentials ecommerce-cluster --zone=europe-west1-b --project=$PROJECT_ID
                            if [ \$? -ne 0 ]; then
                              echo "âŒ Failed to get GKE credentials"
                              exit 1
                            fi

                            echo "ðŸ“¥ Downloading Kubernetes manifests from GCS..."
                            mkdir -p /tmp/k8s-manifests/deployments
                            mkdir -p /tmp/k8s-manifests/services

                            # Download manifests with error handling
                            gsutil -m cp -r gs://e-shop-bucket-1/k8s/deployments/* /tmp/k8s-manifests/deployments/
                            if [ \$? -ne 0 ]; then
                                echo "âŒ Failed to download deployments from GCS"
                                exit 1
                            else
                                echo "âœ… Deployments downloaded successfully"
                            fi

                            gsutil -m cp -r gs://e-shop-bucket-1/k8s/services/* /tmp/k8s-manifests/services/
                            if [ \$? -ne 0 ]; then
                                echo "âŒ Failed to download services from GCS"
                                exit 1
                            else
                                 echo "âœ… Services downloaded successfully"
                            fi

                            echo "ðŸ“‹ Downloaded manifests:"
                            find /tmp/k8s-manifests -name "*.yaml" -o -name "*.yml"

                            echo "ðŸ”„ Updating image tags in deployments..."
                            find /tmp/k8s-manifests/deployments -name "*.yaml" -o -name "*.yml" | while read file; do
                                echo "Updating $file..."
                                # Update :latest tag
                                sed -i.bak "s|:latest|:${BUILD_NUMBER}|g" "$file"
                                # Update specific image references (more robust)
                                sed -i.bak "s|${GCR_REGISTRY}/${PROJECT_ID}/${BACKEND_IMAGE}:[^'\"]*|${GCR_REGISTRY}/${PROJECT_ID}/${BACKEND_IMAGE}:${BUILD_NUMBER}|g" "$file"
                                sed -i.bak "s|${GCR_REGISTRY}/${PROJECT_ID}/${FRONTEND_IMAGE}:[^'\"]*|${GCR_REGISTRY}/${PROJECT_ID}/${FRONTEND_IMAGE}:${BUILD_NUMBER}|g" "$file"
                                sed -i.bak "s|${GCR_REGISTRY}/${PROJECT_ID}/${USER_SERVICE_IMAGE}:[^'\"]*|${GCR_REGISTRY}/${PROJECT_ID}/${USER_SERVICE_IMAGE}:${BUILD_NUMBER}|g" "$file"
                                sed -i.bak "s|${GCR_REGISTRY}/${PROJECT_ID}/${PRODUCT_SERVICE_IMAGE}:[^'\"]*|${GCR_REGISTRY}/${PROJECT_ID}/${PRODUCT_SERVICE_IMAGE}:${BUILD_NUMBER}|g" "$file"
                                sed -i.bak "s|${GCR_REGISTRY}/${PROJECT_ID}/${TRANSACTION_SERVICE_IMAGE}:[^'\"]*|${GCR_REGISTRY}/${PROJECT_ID}/${TRANSACTION_SERVICE_IMAGE}:${BUILD_NUMBER}|g" "$file"
                                sed -i.bak "s|${GCR_REGISTRY}/${PROJECT_ID}/${RECOMMENDATION_API_IMAGE}:[^'\"]*|${GCR_REGISTRY}/${PROJECT_ID}/${RECOMMENDATION_API_IMAGE}:${BUILD_NUMBER}|g" "$file"
                                # Optional: Remove backup files created by sed -i.bak
                                rm -f "$file.bak"
                            done

                            echo "ðŸš€ Applying Kubernetes Deployments..."
                            kubectl apply -f /tmp/k8s-manifests/deployments/ --validate=false
                            if [ \$? -ne 0 ]; then
                                echo "âŒ Failed to apply deployments"
                                kubectl get events --sort-by=.metadata.creationTimestamp
                                exit 1
                            else
                                echo "âœ… Deployments applied successfully"
                            fi

                            echo "ðŸš€ Applying Kubernetes Services..."
                            kubectl apply -f /tmp/k8s-manifests/services/ --validate=false
                            if [ \$? -ne 0 ]; then
                                echo "âŒ Failed to apply services"
                                kubectl get events --sort-by=.metadata.creationTimestamp
                                exit 1
                            else
                                echo "âœ… Services applied successfully"
                            fi

                            echo "â³ Waiting for deployments to be ready..."
                            kubectl rollout status deployment --all --timeout=600s
                            ROLLOUT_STATUS=\$?
                            if [ \$ROLLOUT_STATUS -eq 0 ]; then
                                echo "âœ… All deployments are ready!"
                            else
                                echo "âš ï¸  Some deployments may not be ready (timeout or error), checking status..."
                                kubectl get deployments
                                kubectl get pods --all-namespaces # Show all pods for better debugging
                                # Decide if failure here should stop the pipeline
                                # exit \$ROLLOUT_STATUS # Uncomment if you want pipeline to fail on rollout timeout/error
                            fi

                            echo "ðŸ“Š Final deployment status:"
                            kubectl get deployments,services,pods -o wide
                            echo "âœ… Deployment completed successfully!"
                        '''
                    }
                }
            }
        }
    }
    post {
        always {
            echo "ðŸ§¹ Cleaning upâ€¦"
            // --- CHANGED/ADDED: Clean up the dynamically created secret ---
            script {
                def secretName = "kaniko-secret-${BUILD_NUMBER}"
                echo "ðŸ§¹ Attempting to delete temporary Kubernetes Secret '${secretName}'..."
                try {
                    // Use a container that has kubectl, e.g., gcloud
                    container('gcloud') {
                         sh """
                            # Optional: Re-authenticate if needed for cleanup, though often not necessary for in-cluster ops
                            # export GOOGLE_APPLICATION_CREDENTIALS=\$(pwd)/${env.GCP_CREDENTIALS_ID} # Might need path handling
                            # gcloud auth activate-service-account --key-file=\$(pwd)/${env.GCP_CREDENTIALS_ID}
                            kubectl delete secret ${secretName} --namespace=${env.JENKINS_NAMESPACE} --ignore-not-found=true
                            if [ \$? -eq 0 ]; then
                                echo "âœ… Temporary Kubernetes Secret '${secretName}' deleted."
                            else
                                echo "âš ï¸  Failed to delete temporary Kubernetes Secret '${secretName}', it might not exist."
                            fi
                         """
                    }
                } catch (e) {
                    echo "âš ï¸  Exception during secret cleanup: ${e}"
                }
            }
            sh '''
                # Clean up other temporary files
                rm -rf /tmp/k8s-manifests || true
                rm -rf /tmp/kaniko-auth || true # Clean up temp auth file/dir
                # Note: /workspace/.docker cleanup removed as we don't create it this way anymore
            '''
        }
        success {
            echo "âœ… Pipeline completed successfully!"
            sh '''
                echo "ðŸ“‹ Build Summary:"
                echo "  Build Number: $BUILD_NUMBER"
                echo "  Project ID: $PROJECT_ID"
                echo "  Registry: ${GCR_REGISTRY}"
                echo "  Images built and pushed:"
                echo "    - ${GCR_REGISTRY}/${PROJECT_ID}/${BACKEND_IMAGE}:$BUILD_NUMBER"
                echo "    - ${GCR_REGISTRY}/${PROJECT_ID}/${FRONTEND_IMAGE}:$BUILD_NUMBER"
                echo "    - ${GCR_REGISTRY}/${PROJECT_ID}/${USER_SERVICE_IMAGE}:$BUILD_NUMBER"
                echo "    - ${GCR_REGISTRY}/${PROJECT_ID}/${PRODUCT_SERVICE_IMAGE}:$BUILD_NUMBER"
                echo "    - ${GCR_REGISTRY}/${PROJECT_ID}/${TRANSACTION_SERVICE_IMAGE}:$BUILD_NUMBER"
                echo "    - ${GCR_REGISTRY}/${PROJECT_ID}/${RECOMMENDATION_API_IMAGE}:$BUILD_NUMBER"
            '''
        }
        failure {
            echo "âŒ Pipeline failed. Check logs above for details."
            sh '''
                echo "ðŸ” Debugging information:"
                echo "Current working directory: $(pwd)"
                echo "Available files:"
                find . -maxdepth 3 -name "Dockerfile*" -o -name "dockerfile*" 2>/dev/null || echo "No Dockerfiles found in top 3 levels"
                echo "Kaniko config (if accessible):"
                ls -la /kaniko/.docker/ 2>/dev/null || echo "No Kaniko config found or inaccessible"
                echo "Checking if secret volume was mounted correctly (content might be redacted):"
                cat /kaniko/.docker/config.json 2>/dev/null || echo "Could not read /kaniko/.docker/config.json"
            '''
        }
    }
}